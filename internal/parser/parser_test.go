package parser

import (
	"testing"

	"github.com/standardbeagle/lci/internal/types"
)

// TestTreeSitterParserJavaScript tests JavaScript AST parsing and node generation
func TestTreeSitterParserJavaScript(t *testing.T) {
	parser := NewTreeSitterParser()

	// Complex JavaScript code with functions, classes, imports, method calls
	jsContent := []byte(`
import { helper } from './utils.js';
import React, { useState } from 'react';

class UserManager {
    constructor(config) {
        this.config = config;
        this.users = [];
    }

    async createUser(userData) {
        const validated = this.validateUser(userData);
        if (!validated) {
            throw new Error('Invalid user data');
        }
        
        const user = {
            id: generateId(),
            ...userData,
            createdAt: new Date()
        };
        
        this.users.push(user);
        await this.saveToDatabase(user);
        helper.logAction('user_created', user.id);
        return user;
    }
    
    validateUser(data) {
        return data && data.email && data.name;
    }
    
    saveToDatabase(user) {
        return fetch('/api/users', {
            method: 'POST',
            body: JSON.stringify(user)
        });
    }
}

function generateId() {
    return Math.random().toString(36).substr(2, 9);
}

const userManager = new UserManager({ debug: true });
userManager.createUser({ 
    name: 'John Doe', 
    email: 'john@example.com' 
});
`)

	// Test basic symbol extraction
	blocks, symbols, imports := parser.ParseFile("test.js", jsContent)

	// Verify AST nodes were actually generated by checking for specific symbols
	if len(symbols) == 0 {
		t.Fatal("ParseFile failed to extract any symbols - Tree-sitter AST generation failed")
	}

	// Verify specific function nodes were parsed from AST
	foundCreateUser := false
	foundValidateUser := false
	foundGenerateId := false
	foundUserManager := false

	for _, symbol := range symbols {
		switch symbol.Name {
		case "createUser":
			foundCreateUser = true
			if symbol.Type != types.SymbolTypeMethod {
				t.Errorf("createUser should be parsed as method, got %v", symbol.Type)
			}
		case "validateUser":
			foundValidateUser = true
		case "generateId":
			foundGenerateId = true
			if symbol.Type != types.SymbolTypeFunction {
				t.Errorf("generateId should be parsed as function, got %v", symbol.Type)
			}
		case "UserManager":
			foundUserManager = true
			if symbol.Type != types.SymbolTypeClass {
				t.Errorf("UserManager should be parsed as class, got %v", symbol.Type)
			}
		}
	}

	if !foundCreateUser {
		t.Error("Tree-sitter failed to parse createUser method from AST")
	}
	if !foundValidateUser {
		t.Error("Tree-sitter failed to parse validateUser method from AST")
	}
	if !foundGenerateId {
		t.Error("Tree-sitter failed to parse generateId function from AST")
	}
	if !foundUserManager {
		t.Error("Tree-sitter failed to parse UserManager class from AST")
	}

	// Verify imports were extracted from AST
	if len(imports) == 0 {
		t.Fatal("Tree-sitter failed to extract import nodes from AST")
	}

	foundHelperImport := false
	foundReactImport := false
	for _, imp := range imports {
		if imp.Path == "./utils.js" {
			foundHelperImport = true
		}
		if imp.Path == "react" {
			foundReactImport = true
		}
	}

	if !foundHelperImport || !foundReactImport {
		t.Error("Tree-sitter failed to extract import declarations from AST")
	}

	// Verify block boundaries were extracted from AST nodes
	if len(blocks) == 0 {
		t.Fatal("Tree-sitter failed to extract block boundaries from AST")
	}

	// Test enhanced parsing with relational data
	_, symbols2, _, enhancedSymbols, references, scopeInfo := parser.ParseFileEnhanced("test.js", jsContent)

	// Verify enhanced parsing still works - note: symbol counts may differ after consolidation
	// as ParseFileEnhanced may extract additional detailed symbols compared to ParseFile
	if len(symbols2) == 0 {
		t.Error("ParseFileEnhanced failed to extract any symbols")
	}

	// Verify references were extracted from AST traversal
	if len(references) == 0 {
		t.Error("Tree-sitter AST traversal failed to extract any references")
	}

	// Look for specific reference types that require AST node analysis
	foundCallRef := false
	foundUsageRef := false
	foundImportRef := false

	for _, ref := range references {
		switch ref.Type {
		case types.RefTypeCall:
			foundCallRef = true
		case types.RefTypeUsage:
			foundUsageRef = true
		case types.RefTypeImport:
			foundImportRef = true
		}
	}

	if !foundCallRef {
		t.Error("Tree-sitter AST traversal failed to identify function call references")
	}
	if !foundUsageRef {
		t.Error("Tree-sitter AST traversal failed to identify usage references")
	}
	if !foundImportRef {
		t.Error("Tree-sitter AST traversal failed to identify import references")
	}

	// Verify scope hierarchy was built from AST
	if len(scopeInfo) == 0 {
		t.Error("Tree-sitter failed to build scope hierarchy from AST")
	}

	foundFileScope := false
	foundClassScope := false
	foundMethodScope := false

	for _, scope := range scopeInfo {
		switch scope.Type {
		case types.ScopeTypeFile:
			foundFileScope = true
		case types.ScopeTypeClass:
			foundClassScope = true
			if scope.Name != "UserManager" {
				t.Errorf("Expected class scope name 'UserManager', got '%s'", scope.Name)
			}
		case types.ScopeTypeMethod:
			foundMethodScope = true
		}
	}

	if !foundFileScope {
		t.Error("Tree-sitter failed to create file-level scope")
	}
	if !foundClassScope {
		t.Error("Tree-sitter failed to identify class scope from AST")
	}
	if !foundMethodScope {
		t.Error("Tree-sitter failed to identify method scope from AST")
	}

	// Verify enhanced symbols are populated (would be empty without AST parsing)
	// Note: enhancedSymbols is currently a TODO in the parser, but the structure should exist
	_ = enhancedSymbols // Use to avoid compiler warning

	// Verify symbols are consistent (other data verified above)
	_ = enhancedSymbols // Use to avoid compiler warning
}

// TestTreeSitterParserGo tests Go language AST parsing and node generation
func TestTreeSitterParserGo(t *testing.T) {
	parser := NewTreeSitterParser()

	// Complex Go code with packages, functions, methods, structs
	goContent := []byte(`
package main

import (
	"fmt"
	"net/http"
	"encoding/json"
)

type User struct {
	ID    int    ` + "`json:\"id\"`" + `
	Name  string ` + "`json:\"name\"`" + `
	Email string ` + "`json:\"email\"`" + `
}

type UserService struct {
	users []User
	db    Database
}

func NewUserService(db Database) *UserService {
	return &UserService{
		users: make([]User, 0),
		db:    db,
	}
}

func (us *UserService) CreateUser(user User) error {
	if err := us.validateUser(user); err != nil {
		return fmt.Errorf("validation failed: %w", err)
	}
	
	us.users = append(us.users, user)
	return us.db.Save(user)
}

func (us *UserService) validateUser(user User) error {
	if user.Name == "" {
		return fmt.Errorf("name is required")
	}
	if user.Email == "" {
		return fmt.Errorf("email is required")
	}
	return nil
}

func handleCreateUser(w http.ResponseWriter, r *http.Request) {
	var user User
	if err := json.NewDecoder(r.Body).Decode(&user); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	
	service := NewUserService(nil)
	if err := service.CreateUser(user); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	
	w.WriteHeader(http.StatusCreated)
}
`)

	// Test that Tree-sitter actually parses the Go AST
	_, symbols, imports := parser.ParseFile("test.go", goContent)

	if len(symbols) == 0 {
		t.Fatal("Tree-sitter failed to parse Go AST - no symbols extracted")
	}

	// Verify specific Go constructs were parsed from AST
	foundNewUserService := false
	foundCreateUser := false
	foundValidateUser := false
	foundHandleCreateUser := false

	for _, symbol := range symbols {
		switch symbol.Name {
		case "NewUserService":
			foundNewUserService = true
			if symbol.Type != types.SymbolTypeFunction {
				t.Errorf("NewUserService should be function, got %v", symbol.Type)
			}
		case "CreateUser":
			foundCreateUser = true
			// Should be detected as method due to receiver
		case "validateUser":
			foundValidateUser = true
		case "handleCreateUser":
			foundHandleCreateUser = true
		case "User":
			// Type found
		case "UserService":
			// Type found
		}
	}

	// Verify Tree-sitter parsed all expected symbols from AST
	if !foundNewUserService {
		t.Error("Tree-sitter failed to parse NewUserService function from Go AST")
	}
	if !foundCreateUser {
		t.Error("Tree-sitter failed to parse CreateUser method from Go AST")
	}
	if !foundValidateUser {
		t.Error("Tree-sitter failed to parse validateUser method from Go AST")
	}
	if !foundHandleCreateUser {
		t.Error("Tree-sitter failed to parse handleCreateUser function from Go AST")
	}

	// Verify imports extracted from AST
	if len(imports) == 0 {
		t.Fatal("Tree-sitter failed to extract Go import declarations from AST")
	}

	foundFmtImport := false
	foundHttpImport := false
	foundJsonImport := false

	for _, imp := range imports {
		switch imp.Path {
		case "fmt":
			foundFmtImport = true
		case "net/http":
			foundHttpImport = true
		case "encoding/json":
			foundJsonImport = true
		}
	}

	if !foundFmtImport || !foundHttpImport || !foundJsonImport {
		t.Error("Tree-sitter failed to extract Go import statements from AST")
	}

	// Test enhanced parsing with Go-specific reference extraction
	_, _, _, _, references, scopeInfo := parser.ParseFileEnhanced("test.go", goContent)

	// Verify Go-specific reference patterns were detected
	if len(references) == 0 {
		t.Error("Tree-sitter failed to extract Go references from AST traversal")
	}

	// Look for Go-specific AST node patterns
	foundCallExpression := false

	for _, ref := range references {
		// Check that Go-specific reference extraction is working
		if ref.Type == types.RefTypeCall {
			foundCallExpression = true
		}
	}

	if !foundCallExpression {
		t.Error("Tree-sitter failed to identify Go function call expressions in AST")
	}

	// Verify scope hierarchy includes Go-specific constructs
	if len(scopeInfo) == 0 {
		t.Error("Tree-sitter failed to build Go scope hierarchy from AST")
	}

	foundStructScope := false
	foundFunctionScope := false

	for _, scope := range scopeInfo {
		if scope.Name == "UserService" {
			foundStructScope = true
		}
		if scope.Type == types.ScopeTypeFunction {
			foundFunctionScope = true
		}
	}

	if !foundStructScope {
		t.Error("Tree-sitter failed to identify struct scopes in Go AST")
	}
	if !foundFunctionScope {
		t.Error("Tree-sitter failed to identify function scopes in Go AST")
	}
}

// TestTreeSitterParserPython tests Python AST parsing and node generation
func TestTreeSitterParserPython(t *testing.T) {
	parser := NewTreeSitterParser()

	// Complex Python code with classes, functions, imports, decorators
	pythonContent := []byte(`
import json
import asyncio
from typing import List, Dict, Optional
from dataclasses import dataclass
from datetime import datetime

@dataclass
class User:
    id: int
    name: str
    email: str
    created_at: datetime

class UserRepository:
    def __init__(self, database_url: str):
        self.database_url = database_url
        self.users: List[User] = []
    
    async def create_user(self, user_data: Dict) -> User:
        """Create a new user with validation."""
        if not self.validate_user_data(user_data):
            raise ValueError("Invalid user data")
        
        user = User(
            id=len(self.users) + 1,
            name=user_data['name'],
            email=user_data['email'],
            created_at=datetime.now()
        )
        
        self.users.append(user)
        await self.save_to_database(user)
        return user
    
    def validate_user_data(self, data: Dict) -> bool:
        """Validate user data before creation."""
        required_fields = ['name', 'email']
        return all(field in data and data[field] for field in required_fields)
    
    async def save_to_database(self, user: User) -> None:
        """Save user to database."""
        # Simulate async database operation
        await asyncio.sleep(0.1)
        print(f"Saved user {user.name} to database")

def create_user_service(db_url: str) -> UserRepository:
    """Factory function for creating user service."""
    return UserRepository(db_url)

async def main():
    service = create_user_service("postgresql://localhost/mydb")
    user_data = {
        'name': 'Alice Johnson',
        'email': 'alice@example.com'
    }
    
    try:
        user = await service.create_user(user_data)
        print(f"Created user: {user.name}")
    except ValueError as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    asyncio.run(main())
`)

	// Test Tree-sitter Python AST parsing
	_, symbols, imports := parser.ParseFile("test.py", pythonContent)

	if len(symbols) == 0 {
		t.Fatal("Tree-sitter failed to parse Python AST - no symbols extracted")
	}

	// Verify Python-specific constructs were parsed from AST
	foundUserClass := false
	foundUserRepositoryClass := false
	foundCreateUser := false
	foundValidateUserData := false
	foundCreateUserService := false
	foundMain := false

	for _, symbol := range symbols {
		switch symbol.Name {
		case "User":
			foundUserClass = true
			if symbol.Type != types.SymbolTypeClass {
				t.Errorf("User should be parsed as class, got %v", symbol.Type)
			}
		case "UserRepository":
			foundUserRepositoryClass = true
			if symbol.Type != types.SymbolTypeClass {
				t.Errorf("UserRepository should be parsed as class, got %v", symbol.Type)
			}
		case "create_user":
			foundCreateUser = true
		case "validate_user_data":
			foundValidateUserData = true
		case "create_user_service":
			foundCreateUserService = true
			if symbol.Type != types.SymbolTypeFunction {
				t.Errorf("create_user_service should be function, got %v", symbol.Type)
			}
		case "main":
			foundMain = true
		}
	}

	// Verify Tree-sitter extracted all Python symbols from AST
	if !foundUserClass {
		t.Error("Tree-sitter failed to parse User class from Python AST")
	}
	if !foundUserRepositoryClass {
		t.Error("Tree-sitter failed to parse UserRepository class from Python AST")
	}
	if !foundCreateUser {
		t.Error("Tree-sitter failed to parse create_user method from Python AST")
	}
	if !foundValidateUserData {
		t.Error("Tree-sitter failed to parse validate_user_data method from Python AST")
	}
	if !foundCreateUserService {
		t.Error("Tree-sitter failed to parse create_user_service function from Python AST")
	}
	if !foundMain {
		t.Error("Tree-sitter failed to parse main function from Python AST")
	}

	// Verify Python imports were extracted from AST
	if len(imports) == 0 {
		t.Fatal("Tree-sitter failed to extract Python import statements from AST")
	}

	// Test enhanced parsing for Python-specific reference patterns
	_, _, _, _, references, scopeInfo := parser.ParseFileEnhanced("test.py", pythonContent)

	// Verify Python references were extracted through AST traversal
	if len(references) == 0 {
		t.Error("Tree-sitter failed to extract Python references from AST")
	}

	// Look for Python-specific reference patterns
	foundCallRef := false

	for _, ref := range references {
		if ref.Type == types.RefTypeCall {
			foundCallRef = true
		}
	}

	if !foundCallRef {
		t.Error("Tree-sitter failed to identify Python function calls in AST")
	}

	// Verify Python scope hierarchy
	if len(scopeInfo) == 0 {
		t.Error("Tree-sitter failed to build Python scope hierarchy from AST")
	}

	foundPythonClassScope := false
	foundPythonFunctionScope := false

	for _, scope := range scopeInfo {
		if scope.Type == types.ScopeTypeClass && scope.Name == "UserRepository" {
			foundPythonClassScope = true
		}
		if scope.Type == types.ScopeTypeFunction {
			foundPythonFunctionScope = true
		}
	}

	if !foundPythonClassScope {
		t.Error("Tree-sitter failed to identify Python class scopes in AST")
	}
	if !foundPythonFunctionScope {
		t.Error("Tree-sitter failed to identify Python function scopes in AST")
	}
}

// TestTreeSitterParserTypeScript tests TypeScript AST parsing and node generation
func TestTreeSitterParserTypeScript(t *testing.T) {
	parser := NewTreeSitterParser()

	// Complex TypeScript code with interfaces, generics, decorators
	tsContent := []byte(`
import { Observable } from 'rxjs';
import { Injectable, Component } from '@angular/core';

interface User {
    id: number;
    name: string;
    email: string;
    createdAt: Date;
}

interface UserRepository<T extends User> {
    findById(id: number): Promise<T | null>;
    create(user: Omit<T, 'id'>): Promise<T>;
    update(id: number, updates: Partial<T>): Promise<T>;
    delete(id: number): Promise<void>;
}

@Injectable()
class UserService implements UserRepository<User> {
    private users: User[] = [];
    
    constructor(private httpClient: HttpClient) {}
    
    async findById(id: number): Promise<User | null> {
        const user = this.users.find(u => u.id === id);
        if (!user) {
            const response = await this.httpClient.get<User>(` + "`/api/users/${id}`" + `).toPromise();
            return response || null;
        }
        return user;
    }
    
    async create(userData: Omit<User, 'id'>): Promise<User> {
        const newUser: User = {
            ...userData,
            id: this.generateId(),
            createdAt: new Date()
        };
        
        this.users.push(newUser);
        await this.saveToServer(newUser);
        return newUser;
    }
    
    async update(id: number, updates: Partial<User>): Promise<User> {
        const existingUser = await this.findById(id);
        if (!existingUser) {
            throw new Error(` + "`User with id ${id} not found`" + `);
        }
        
        const updatedUser = { ...existingUser, ...updates };
        this.users = this.users.map(u => u.id === id ? updatedUser : u);
        await this.saveToServer(updatedUser);
        return updatedUser;
    }
    
    async delete(id: number): Promise<void> {
        this.users = this.users.filter(u => u.id !== id);
        await this.httpClient.delete(` + "`/api/users/${id}`" + `).toPromise();
    }
    
    private generateId(): number {
        return Math.floor(Math.random() * 1000000);
    }
    
    private async saveToServer(user: User): Promise<void> {
        await this.httpClient.post('/api/users', user).toPromise();
    }
}

@Component({
    selector: 'app-user-list',
    template: ` + "`<div>User List</div>`" + `
})
export class UserListComponent {
    users$: Observable<User[]>;
    
    constructor(private userService: UserService) {
        this.users$ = this.userService.getUsers();
    }
    
    async createUser(userData: Omit<User, 'id'>): Promise<void> {
        try {
            await this.userService.create(userData);
            this.refreshUsers();
        } catch (error) {
            console.error('Failed to create user:', error);
        }
    }
    
    private refreshUsers(): void {
        this.users$ = this.userService.getUsers();
    }
}
`)

	// Test Tree-sitter TypeScript AST parsing
	_, symbols, imports := parser.ParseFile("test.ts", tsContent)

	if len(symbols) == 0 {
		t.Fatal("Tree-sitter failed to parse TypeScript AST - no symbols extracted")
	}

	// Verify TypeScript-specific constructs were parsed from AST
	foundUserInterface := false
	foundUserRepositoryInterface := false
	foundUserService := false
	foundUserListComponent := false
	foundFindById := false
	foundCreate := false
	foundGenerateId := false

	for _, symbol := range symbols {
		switch symbol.Name {
		case "User":
			foundUserInterface = true
			if symbol.Type != types.SymbolTypeInterface {
				t.Errorf("User should be parsed as interface, got %v", symbol.Type)
			}
		case "UserRepository":
			foundUserRepositoryInterface = true
			if symbol.Type != types.SymbolTypeInterface {
				t.Errorf("UserRepository should be parsed as interface, got %v", symbol.Type)
			}
		case "UserService":
			foundUserService = true
			if symbol.Type != types.SymbolTypeClass {
				t.Errorf("UserService should be parsed as class, got %v", symbol.Type)
			}
		case "UserListComponent":
			foundUserListComponent = true
		case "findById":
			foundFindById = true
		case "create":
			foundCreate = true
		case "generateId":
			foundGenerateId = true
		}
	}

	// Verify Tree-sitter extracted TypeScript-specific symbols from AST
	if !foundUserInterface {
		t.Error("Tree-sitter failed to parse User interface from TypeScript AST")
	}
	if !foundUserRepositoryInterface {
		t.Error("Tree-sitter failed to parse UserRepository interface from TypeScript AST")
	}
	if !foundUserService {
		t.Error("Tree-sitter failed to parse UserService class from TypeScript AST")
	}
	if !foundUserListComponent {
		t.Error("Tree-sitter failed to parse UserListComponent class from TypeScript AST")
	}
	if !foundFindById {
		t.Error("Tree-sitter failed to parse findById method from TypeScript AST")
	}
	if !foundCreate {
		t.Error("Tree-sitter failed to parse create method from TypeScript AST")
	}
	if !foundGenerateId {
		t.Error("Tree-sitter failed to parse generateId private method from TypeScript AST")
	}

	// Verify TypeScript imports were extracted from AST
	if len(imports) == 0 {
		t.Fatal("Tree-sitter failed to extract TypeScript import statements from AST")
	}

	foundRxjsImport := false
	foundAngularImport := false

	for _, imp := range imports {
		if imp.Path == "rxjs" {
			foundRxjsImport = true
		}
		if imp.Path == "@angular/core" {
			foundAngularImport = true
		}
	}

	if !foundRxjsImport || !foundAngularImport {
		t.Error("Tree-sitter failed to extract TypeScript import declarations from AST")
	}

	// Test enhanced parsing for TypeScript-specific patterns
	_, _, _, _, references, scopeInfo := parser.ParseFileEnhanced("test.ts", tsContent)

	// Verify TypeScript references were extracted
	if len(references) == 0 {
		t.Error("Tree-sitter failed to extract TypeScript references from AST")
	}

	// Verify TypeScript scope hierarchy includes interfaces
	if len(scopeInfo) == 0 {
		t.Error("Tree-sitter failed to build TypeScript scope hierarchy from AST")
	}

	foundInterfaceScope := false
	foundClassScope := false

	for _, scope := range scopeInfo {
		if scope.Type == types.ScopeTypeInterface {
			foundInterfaceScope = true
		}
		if scope.Type == types.ScopeTypeClass && scope.Name == "UserService" {
			foundClassScope = true
		}
	}

	if !foundInterfaceScope {
		t.Error("Tree-sitter failed to identify TypeScript interface scopes in AST")
	}
	if !foundClassScope {
		t.Error("Tree-sitter failed to identify TypeScript class scopes in AST")
	}
}

// TestTreeSitterASTWalkingAndNodeAccess tests that Tree-sitter is actually walking AST nodes
func TestTreeSitterASTWalkingAndNodeAccess(t *testing.T) {
	parser := NewTreeSitterParser()

	// Code designed to test specific AST node access patterns
	jsContent := []byte(`
function testFunction() {
    const obj = {
        method: function() {
            return this.property.nested.call();
        },
        arrow: () => {
            helper.utility.process(data);
        }
    };
    
    obj.method();
    obj.arrow();
    return obj;
}
`)

	// Test that enhanced parsing actually walks the AST
	_, _, _, _, references, _ := parser.ParseFileEnhanced("ast_test.js", jsContent)

	if len(references) == 0 {
		t.Fatal("Tree-sitter AST walking failed - no references extracted")
	}

	// Verify that specific AST node types were encountered during traversal
	foundMemberExpression := false
	foundCallExpression := false
	foundIdentifierUsage := false

	for _, ref := range references {
		// These reference types can only be created by walking the AST and analyzing nodes
		if ref.Type == types.RefTypeUsage {
			foundMemberExpression = true
		}
		if ref.Type == types.RefTypeCall {
			foundCallExpression = true
		}
		if ref.Line > 0 && ref.Column > 0 {
			foundIdentifierUsage = true
		}
	}

	if !foundMemberExpression {
		t.Error("Tree-sitter AST walker failed to identify member expressions")
	}
	if !foundCallExpression {
		t.Error("Tree-sitter AST walker failed to identify call expressions")
	}
	if !foundIdentifierUsage {
		t.Error("Tree-sitter AST walker failed to extract node position information")
	}

	// Verify that context extraction is working (requires AST node access)
	contextFound := false
	for _, ref := range references {
		if len(ref.Context) > 0 {
			contextFound = true
			break
		}
	}

	if !contextFound {
		t.Error("Tree-sitter failed to extract context around references (requires AST node access)")
	}
}

// TestTreeSitterNodeFieldAccess tests that Tree-sitter is accessing specific node fields
func TestTreeSitterNodeFieldAccess(t *testing.T) {
	parser := NewTreeSitterParser()

	// Code specifically designed to test field access on AST nodes
	goContent := []byte(`
package main

func (receiver *Type) methodName(param1 string, param2 int) (string, error) {
    return receiver.field.SubField(), nil
}

type StructType struct {
    FieldName string
    Number    int
}
`)

	blocks, symbols, _ := parser.ParseFile("field_test.go", goContent)

	// Verify that method parsing accessed the receiver field of method_declaration nodes
	foundMethodWithReceiver := false
	for _, symbol := range symbols {
		if symbol.Name == "methodName" {
			foundMethodWithReceiver = true
			// This can only be extracted by accessing the node's "receiver" field
			break
		}
	}

	if !foundMethodWithReceiver {
		t.Error("Tree-sitter failed to access 'receiver' field of method_declaration AST node")
	}

	// Verify that function name extraction used the "name" field access
	foundCorrectlyNamedSymbol := false
	for _, symbol := range symbols {
		if symbol.Name != "" && symbol.Line > 0 {
			foundCorrectlyNamedSymbol = true
			break
		}
	}

	if !foundCorrectlyNamedSymbol {
		t.Error("Tree-sitter failed to access 'name' field of AST nodes for symbol extraction")
	}

	// Verify that line/column information comes from AST node points
	foundPositionInfo := false
	for _, symbol := range symbols {
		if symbol.Line > 0 && symbol.Column > 0 && symbol.EndLine >= symbol.Line {
			foundPositionInfo = true
			break
		}
	}

	if !foundPositionInfo {
		t.Error("Tree-sitter failed to extract position information from AST node StartPoint/EndPoint")
	}

	// Verify that block boundaries use AST node ranges
	foundBlockWithRange := false
	for _, block := range blocks {
		if block.Start >= 0 && block.End > block.Start {
			foundBlockWithRange = true
			break
		}
	}

	if !foundBlockWithRange {
		t.Error("Tree-sitter failed to extract block ranges from AST node boundaries")
	}
}

// TestTreeSitterQueryExecution tests that Tree-sitter queries are actually executed on AST
func TestTreeSitterQueryExecution(t *testing.T) {
	parser := NewTreeSitterParser()

	// Code designed to match specific Tree-sitter query patterns
	jsContent := []byte(`
export function exportedFunction() {
    return "test";
}

const arrowFunction = () => {
    console.log("arrow");
};

class ExportedClass {
    methodInClass() {
        this.call();
    }
}

export { arrowFunction };
export default ExportedClass;
`)

	_, symbols, _ := parser.ParseFile("query_test.js", jsContent)

	// These symbols can only be found if Tree-sitter queries are executed on the AST
	foundExportedFunction := false
	foundArrowFunction := false
	foundExportedClass := false
	foundMethodInClass := false

	for _, symbol := range symbols {
		switch symbol.Name {
		case "exportedFunction":
			foundExportedFunction = true
		case "arrowFunction":
			foundArrowFunction = true
		case "ExportedClass":
			foundExportedClass = true
		case "methodInClass":
			foundMethodInClass = true
		}
	}

	if !foundExportedFunction {
		t.Error("Tree-sitter query failed to match function_declaration pattern")
	}
	if !foundArrowFunction {
		t.Error("Tree-sitter query failed to match arrow_function pattern")
	}
	if !foundExportedClass {
		t.Error("Tree-sitter query failed to match class_declaration pattern")
	}
	if !foundMethodInClass {
		t.Error("Tree-sitter query failed to match method_definition pattern")
	}

	// Verify that query captures are working (capture names like @function.name)
	if len(symbols) == 0 {
		t.Fatal("Tree-sitter query execution produced no captures")
	}

	// Check that symbol types are correctly identified through query matching
	correctTypesFound := 0
	for _, symbol := range symbols {
		switch symbol.Name {
		case "exportedFunction", "arrowFunction":
			if symbol.Type == types.SymbolTypeFunction {
				correctTypesFound++
			}
		case "ExportedClass":
			if symbol.Type == types.SymbolTypeClass {
				correctTypesFound++
			}
		case "methodInClass":
			if symbol.Type == types.SymbolTypeMethod {
				correctTypesFound++
			}
		}
	}

	if correctTypesFound == 0 {
		t.Error("Tree-sitter query captures failed to identify correct symbol types")
	}

	// The existence of any symbols proves that queries were executed on the AST
	// because the parser returns empty results if queries fail
	if len(symbols) < 3 {
		t.Error("Tree-sitter query execution returned fewer symbols than expected - query may have failed")
	}
}
