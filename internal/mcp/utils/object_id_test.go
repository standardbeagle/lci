package utils

import (
	"fmt"
	"testing"

	"github.com/standardbeagle/lci/internal/searchtypes"
	"github.com/standardbeagle/lci/internal/types"
)

func TestParseObjectID_Base63(t *testing.T) {
	tests := []struct {
		name     string
		objectID string
		wantType string
		wantErr  bool
	}{
		{
			name:     "simple base63 id",
			objectID: "VE",
			wantType: "symbol",
			wantErr:  false,
		},
		{
			name:     "longer base63 id",
			objectID: "ABC123",
			wantType: "symbol",
			wantErr:  false,
		},
		{
			name:     "base63 with underscore",
			objectID: "test_var",
			wantType: "symbol",
			wantErr:  false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := ParseObjectID(tt.objectID)
			if (err != nil) != tt.wantErr {
				t.Errorf("ParseObjectID() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !tt.wantErr && got.Type != tt.wantType {
				t.Errorf("ParseObjectID() type = %v, want %v", got.Type, tt.wantType)
			}
		})
	}
}

func TestParseObjectID_NumericPrefix(t *testing.T) {
	// Test the symbol: prefix which uses numeric parsing
	// Note: Pure numeric strings like "12345" are valid base63 and will be
	// decoded as base63, not decimal. The numeric parsing is only used when
	// base63 parsing fails or when using the "symbol:" prefix.
	tests := []struct {
		name       string
		objectID   string
		wantSymbol types.SymbolID
		wantErr    bool
	}{
		{
			name:       "symbol prefix with small id",
			objectID:   "symbol:12345",
			wantSymbol: types.SymbolID(12345),
			wantErr:    false,
		},
		{
			name:       "symbol prefix with large id exceeding 32-bit",
			objectID:   "symbol:5000000000",
			wantSymbol: types.SymbolID(5000000000),
			wantErr:    false,
		},
		{
			name:       "symbol prefix with max uint64",
			objectID:   "symbol:18446744073709551615",
			wantSymbol: types.SymbolID(18446744073709551615),
			wantErr:    false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := ParseObjectID(tt.objectID)
			if (err != nil) != tt.wantErr {
				t.Errorf("ParseObjectID() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !tt.wantErr && got.SymbolID != tt.wantSymbol {
				t.Errorf("ParseObjectID() symbolID = %v, want %v", got.SymbolID, tt.wantSymbol)
			}
		})
	}
}

func TestEncodeDecodeSymbolID_RoundTrip(t *testing.T) {
	// Test that encoding then decoding produces the original value
	testIDs := []types.SymbolID{
		0,
		1,
		62,
		63,
		100,
		1000,
		10000,
		100000,
		1000000,
		4294967295,  // max uint32
		5000000000,  // exceeds uint32
		10000000000, // large 64-bit value
	}

	for _, id := range testIDs {
		t.Run(fmt.Sprintf("id_%d", id), func(t *testing.T) {
			// Encode using searchtypes.EncodeSymbolID
			encoded := searchtypes.EncodeSymbolID(id)

			// Decode using ParseSymbolID
			decoded, err := ParseSymbolID(encoded)
			if err != nil {
				t.Errorf("ParseSymbolID(%q) error = %v", encoded, err)
				return
			}

			if decoded != id {
				t.Errorf("Round-trip failed: original=%d, encoded=%q, decoded=%d", id, encoded, decoded)
			}
		})
	}
}

func TestParseObjectID_PrefixedFormats(t *testing.T) {
	tests := []struct {
		name     string
		objectID string
		wantType string
		wantErr  bool
	}{
		{
			name:     "symbol prefix",
			objectID: "symbol:12345",
			wantType: "symbol",
			wantErr:  false,
		},
		{
			name:     "file prefix",
			objectID: "file:123",
			wantType: "file",
			wantErr:  false,
		},
		{
			name:     "file with line",
			objectID: "file:123+line:42",
			wantType: "file",
			wantErr:  false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := ParseObjectID(tt.objectID)
			if (err != nil) != tt.wantErr {
				t.Errorf("ParseObjectID() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !tt.wantErr && got.Type != tt.wantType {
				t.Errorf("ParseObjectID() type = %v, want %v", got.Type, tt.wantType)
			}
		})
	}
}

func TestParseObjectID_CodeInsightCompatibility(t *testing.T) {
	// This test ensures that IDs generated by code_insight work with get_context
	// This was the original bug: code_insight generated IDs that get_context couldn't parse

	// Simulate what code_insight does: encode a SymbolID
	symbolID := types.SymbolID(123456789)
	encoded := searchtypes.EncodeSymbolID(symbolID)

	// Simulate what get_context does: parse the encoded ID
	parsed, err := ParseObjectID(encoded)
	if err != nil {
		t.Fatalf("ParseObjectID(%q) failed: %v", encoded, err)
	}

	if parsed.SymbolID != symbolID {
		t.Errorf("Code insight -> get_context compatibility failed: original=%d, parsed=%d", symbolID, parsed.SymbolID)
	}

	// Also test with a large SymbolID that exceeds 32 bits
	largeSymbolID := types.SymbolID(5000000000) // > 4294967295 (max uint32)
	largeEncoded := searchtypes.EncodeSymbolID(largeSymbolID)

	largeParsed, err := ParseObjectID(largeEncoded)
	if err != nil {
		t.Fatalf("ParseObjectID(%q) failed for large ID: %v", largeEncoded, err)
	}

	if largeParsed.SymbolID != largeSymbolID {
		t.Errorf("Large SymbolID compatibility failed: original=%d, parsed=%d", largeSymbolID, largeParsed.SymbolID)
	}
}

// TestParseObjectID_Base63Decoding validates base63 decoding is correct
// This is critical for get_context to correctly look up symbols
func TestParseObjectID_Base63Decoding(t *testing.T) {
	tests := []struct {
		name     string
		objectID string
		wantID   types.SymbolID
	}{
		// Single character IDs (first 63 values)
		{"A = 0", "A", 0},
		{"B = 1", "B", 1},
		{"Z = 25", "Z", 25},
		{"a = 26", "a", 26},
		{"z = 51", "z", 51},
		{"0 = 52", "0", 52},
		{"9 = 61", "9", 61},
		{"_ = 62", "_", 62},

		// Two character IDs (63 to 63*63-1)
		{"BA = 63", "BA", 63},
		{"BB = 64", "BB", 64},

		// Real-world IDs from search results
		{"VE (common ID)", "VE", 21*63 + 4}, // V=21, E=4
		{"BSb (from bug report)", "BSb", 1*63*63 + 18*63 + 27},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			parsed, err := ParseObjectID(tt.objectID)
			if err != nil {
				t.Fatalf("ParseObjectID(%q) error = %v", tt.objectID, err)
			}
			if parsed.SymbolID != tt.wantID {
				t.Errorf("ParseObjectID(%q) = %d, want %d", tt.objectID, parsed.SymbolID, tt.wantID)
			}
		})
	}
}

// TestParseObjectID_SearchResultToContext tests the full workflow:
// search results produce object IDs that must be usable with get_context
func TestParseObjectID_SearchResultToContext(t *testing.T) {
	// Test cases representing real search result -> get_context workflows
	testCases := []struct {
		name        string
		searchID    string // ID as it appears in search results (o=XX)
		description string
	}{
		{"simple_two_char", "VE", "common short ID from search"},
		{"three_char", "BSb", "three char ID that triggered function::0 bug"},
		{"longer_id", "ABC123", "longer mixed-case ID"},
		{"with_underscore", "test_var", "ID containing underscore"},
		{"all_lowercase", "abc", "all lowercase ID"},
		{"all_uppercase", "XYZ", "all uppercase ID"},
		{"numeric_suffix", "fn42", "ID with numeric suffix"},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Step 1: Parse the ID as get_context would
			parsed, err := ParseObjectID(tc.searchID)
			if err != nil {
				t.Fatalf("ParseObjectID(%q) failed: %v", tc.searchID, err)
			}

			// Step 2: Verify we get a valid SymbolID (not 0 for multi-char IDs)
			if len(tc.searchID) > 1 && parsed.SymbolID == 0 {
				t.Errorf("ParseObjectID(%q) returned SymbolID=0, expected non-zero for multi-char ID", tc.searchID)
			}

			// Step 3: Verify type is "symbol"
			if parsed.Type != "symbol" {
				t.Errorf("ParseObjectID(%q) type = %q, want 'symbol'", tc.searchID, parsed.Type)
			}

			// Step 4: Verify round-trip encoding/decoding
			reEncoded := searchtypes.EncodeSymbolID(parsed.SymbolID)
			reParsed, err := ParseObjectID(reEncoded)
			if err != nil {
				t.Fatalf("Round-trip ParseObjectID(%q) failed: %v", reEncoded, err)
			}
			if reParsed.SymbolID != parsed.SymbolID {
				t.Errorf("Round-trip failed: original=%d, re-encoded=%q, re-parsed=%d",
					parsed.SymbolID, reEncoded, reParsed.SymbolID)
			}

			t.Logf("%s: %q -> SymbolID=%d -> %q", tc.description, tc.searchID, parsed.SymbolID, reEncoded)
		})
	}
}

// TestParseObjectID_CommaSeparatedMultiple tests parsing comma-separated IDs
// as used in get_context for batch lookups
func TestParseObjectID_CommaSeparatedMultiple(t *testing.T) {
	// get_context accepts comma-separated IDs like "VE,tG,Ab"
	multipleIDs := "VE,tG,Ab"

	// The handler splits by comma and processes each
	ids := []string{"VE", "tG", "Ab"}

	for i, id := range ids {
		parsed, err := ParseObjectID(id)
		if err != nil {
			t.Fatalf("ParseObjectID(%q) from %q failed: %v", id, multipleIDs, err)
		}

		if parsed.SymbolID == 0 && len(id) > 1 {
			t.Errorf("ID %d (%q) returned SymbolID=0", i, id)
		}

		t.Logf("ID %d: %q -> SymbolID=%d", i, id, parsed.SymbolID)
	}
}
